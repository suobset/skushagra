"use strict";(self.webpackChunkskushagra=self.webpackChunkskushagra||[]).push([[4116],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),h=i,u=c["".concat(l,".").concat(h)]||c[h]||m[h]||o;return n?a.createElement(u,r(r({ref:t},d),{},{components:n})):a.createElement(u,r({ref:t},d))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7349:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:2},r="MorbiOS",s={unversionedId:"independent/morbios",id:"independent/morbios",title:"MorbiOS",description:"A completely built-from-scratch Operating System, in collaboration with @anvitha305. More details here soon.",source:"@site/docs/independent/morbios.md",sourceDirName:"independent",slug:"/independent/morbios",permalink:"/docs/independent/morbios",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Disclaimer",permalink:"/docs/independent/code-projects"},next:{title:"Scripting Shenanigans",permalink:"/docs/independent/scripting-shenanigans"}},l={},p=[{value:"Project Kickoff",id:"project-kickoff",level:2},{value:"History Lesson",id:"history-lesson",level:3},{value:"GNU and the Birth of Open Source",id:"gnu-and-the-birth-of-open-source",level:4},{value:"Enter Linux",id:"enter-linux",level:4},{value:"A Parallel Timeline: DOS, Windows, NeXT, and BeOS",id:"a-parallel-timeline-dos-windows-next-and-beos",level:4},{value:"Microsoft and Windows",id:"microsoft-and-windows",level:5},{value:"NeXT and Apple",id:"next-and-apple",level:5},{value:"Other stuff",id:"other-stuff",level:5},{value:"UNIX Today: The Ubiquitous Choice",id:"unix-today-the-ubiquitous-choice",level:3},{value:"Kernel Development",id:"kernel-development",level:2},{value:"Userspace and System Calls",id:"userspace-and-system-calls",level:3},{value:"Development Methods",id:"development-methods",level:3},{value:"Bootloader",id:"bootloader",level:3},{value:"Kernel to User Space",id:"kernel-to-user-space",level:3},{value:"Boot Processes",id:"boot-processes",level:3},{value:"General User Space Development",id:"general-user-space-development",level:3}],d={toc:p},c="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"morbios"},"MorbiOS"),(0,i.kt)("p",null,"A completely built-from-scratch Operating System, in collaboration with ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/anvitha305"},"@anvitha305"),". More details here soon."),(0,i.kt)("p",null,"GitHub Repository: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/anvitha305/morbios"},"https://github.com/anvitha305/morbios")),(0,i.kt)("p",null,"Disclaimer: Please Read ",(0,i.kt)("a",{parentName:"p",href:"./code-projects"},"About Code Projects in the Finechive")," for more info."),(0,i.kt)("h2",{id:"project-kickoff"},"Project Kickoff"),(0,i.kt)("p",null,"The following are some (badly written) notes regarding Operating System development, what has already been done, and how we got to this point today. In essence, I want to cover the topics of kernel development, how that latches on to userspace applications, and different development methods that I have targeted for this project. "),(0,i.kt)("p",null,"As per the bootloader, we are personally making it GNU GRUB compatible. However, we want to make this whole thing from scratch, and that involves a bootloader. This is currently exclusively handled by my co-collaborator Anvitha, who I will be discussing the specifics of the bootloader with and reporting the same here as well. Hopefully they get a website in the meantime :') "),(0,i.kt)("p",null,"If you were to go out and ask, \"hey, I wanna build an Operating System but don't know what kernel to use...can you help me??\", chances are you will likely hear to base it on some variant of UNIX. It's pretty ubiquitous in the OS world, as while you may disagree with some UNIX philosophies, it is used widely enough (and is portable enough) that it makes sense as a starting point."),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"history-lesson"},"History Lesson"),(0,i.kt)("p",null,'Historically (and this is my recollection so may be inaccurate), UNIX was a proprietary OS created by our friends at Bell Labs (AT&T), used widely in mainframe computing servers and such. Most user computers were terminals that would connect to the "mainframe", and have a terminal output. This command line interface was UNIX, an OS so modular it treats every single thing as a file, stored on a root location. Including directories and file paths, binaries, logs, configs, and user-created files, with everything else in between...those are files as well.'),(0,i.kt)("p",null,"Thanks to the user friendliness of UNIX, along with the prevalence of Mainframe computation, UNIX became mega popular. This intrigued Richard Stallman, who loved UNIX's modularity and open nature but hated the fact that it was proprietary and could not be freely distributed."),(0,i.kt)("h4",{id:"gnu-and-the-birth-of-open-source"},"GNU and the Birth of Open Source"),(0,i.kt)("p",null,"So, Richard Stallman got to work on the GNU project (GNU's Not Unix), aiming to create a free, open-source UNIX-like OS. This was the spark that ignited the free software movement, which later evolved into the broader open-source movement. The GNU project created many essential tools and utilities needed for a functional operating system, but they were missing one crucial component: the kernel."),(0,i.kt)("h4",{id:"enter-linux"},"Enter Linux"),(0,i.kt)("p",null,"Enter Linus Torvalds. In 1991, Linus, a Finnish computer science student, started working on his own kernel as a hobby project. This kernel, combined with the GNU utilities, formed a fully functional operating system. This powerful duo, GNU and Linux, became what we now call the GNU/Linux operating system, or more commonly, just Linux. It brought the philosophy of open source to the mainstream, and today, Linux powers everything from supercomputers to smartphones."),(0,i.kt)("h4",{id:"a-parallel-timeline-dos-windows-next-and-beos"},"A Parallel Timeline: DOS, Windows, NeXT, and BeOS"),(0,i.kt)("p",null,"While UNIX was making waves in the computing world, other significant developments were happening elsewhere. In the early 1980s, Microsoft and IBM collaborated to create an operating system for IBM's personal computers. This OS, known as DOS (Disk Operating System), became the foundation for Microsoft's future operating systems. DOS was a simple, command-line-based OS that was user-friendly and affordable, making personal computing accessible to the masses."),(0,i.kt)("h5",{id:"microsoft-and-windows"},"Microsoft and Windows"),(0,i.kt)("p",null,"Microsoft quickly saw the potential of graphical user interfaces (GUIs) and began developing Windows as a shell on top of DOS. The first version of Windows, released in 1985, was not very impressive, but it laid the groundwork for future developments. Over the years, Windows evolved, with significant releases like Windows 95, which integrated DOS and Windows into a single product, and Windows NT, which introduced a new, more robust kernel architecture."),(0,i.kt)("p",null,"The NT kernel, which powers modern versions of Windows, was designed for high reliability and security. Despite the rise of UNIX-like systems, Windows has maintained a dominant presence in the desktop and enterprise markets."),(0,i.kt)("h5",{id:"next-and-apple"},"NeXT and Apple"),(0,i.kt)("p",null,"Meanwhile, Steve Jobs, after leaving Apple, founded NeXT. The NeXTSTEP operating system, developed by his company, was based on the UNIX philosophy and introduced several advanced features, including a sophisticated GUI and object-oriented programming environment. When Jobs returned to Apple, NeXTSTEP became the foundation for macOS."),(0,i.kt)("p",null,"Today, macOS runs on a UNIX-like core called Darwin, which is based on the XNU kernel, combining elements from Mach (a microkernel) and components from BSD (a UNIX derivative). This makes macOS a powerful and user-friendly operating system that is also highly compatible with UNIX standards."),(0,i.kt)("h5",{id:"other-stuff"},"Other stuff"),(0,i.kt)("p",null,"Other efforts include more experimental and niche systems like Haiku, which continues the legacy of BeOS, and MINIX, a minimalistic microkernel-based system designed for educational purposes. BSD (Berkeley Software Distribution) is yet another UNIX derivative that gave way to Darwin. Despite their differences, most of these projects aim to achieve the robustness, flexibility, and modularity that UNIX is known for, highlighting its lasting influence in the OS world."),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"unix-today-the-ubiquitous-choice"},"UNIX Today: The Ubiquitous Choice"),(0,i.kt)("p",null,"Fast forward to today, and UNIX and its derivatives are everywhere. Apple's *OS, with its Darwin core, is a direct descendant of UNIX. Android, the world's most popular mobile operating system, is based on the Linux kernel. Even many network devices, servers, and supercomputers run on UNIX-like systems due to their stability, security, and flexibility. "),(0,i.kt)("p",null,"In contrast, Microsoft Windows remains the only major operating system using the NT kernel. However, the influence of UNIX can still be felt, as Windows has introduced features like the Windows Subsystem for Linux (WSL), allowing users to run a Linux environment directly within Windows."),(0,i.kt)("p",null,"So, if we were to create an OS and needed a kernel, people would say to just use the open source Linux kernel or one of the many UNIX derivatives. We only slightly refuse to, here's why."),(0,i.kt)("h2",{id:"kernel-development"},"Kernel Development"),(0,i.kt)("p",null,"Now, speaking of kernels, the kernel is the heart of the operating system. It manages hardware resources and allows software to run. There are several types of kernels: monolithic kernels, microkernels, and hybrid kernels, to name a few. "),(0,i.kt)("p",null,"Monolithic kernels, like the Linux kernel, include all the essential services in one large block of code. This can make them faster but also harder to debug and maintain. Microkernels, on the other hand, strip the kernel down to the bare minimum, running most services in user space. This makes them more modular and easier to maintain but can lead to performance overhead due to the increased number of context switches. Hybrid kernels try to balance these two approaches, aiming to get the best of both worlds."),(0,i.kt)("p",null,"Given the dominance of UNIX-like systems, one might wonder why I'm choosing a different path for my own OS development. My choice is driven by a desire to build something unique, avoiding reliance on existing ",(0,i.kt)("em",{parentName:"p"},"completed")," UNIX systems to ensure a truly original creation. That's where ReactOS, and GNU Hurd come in."),(0,i.kt)("p",null,"Instead of using the widely adopted and already completed Linux kernel, we are focusing on GNU Hurd, another UNIX-like kernel that remains incomplete but holds great potential. By working on Hurd, we can contribute to its development while also creating a unique kernel for our OS. This approach ensures that our user space applications are built on a foundation that is not influenced by existing UNIX systems."),(0,i.kt)("p",null,"ReactOS is an open-source operating system designed to be binary-compatible with Windows applications and drivers. It provides a familiar environment for developing and running software without the direct influence of UNIX or Linux, or any methods to run it as well (like WSL or Cygwin). This makes it an ideal platform for our project, as we aim to develop my kernel without inadvertently relying on UNIX components."),(0,i.kt)("p",null,"My co-collaborator Anvitha is possibly relying on Windows as is, but also with GNU Hurd as our main kernel (which is incomplete and will require work). We just do not want to work on an OS that already has a completed UNIX under the hood, since this is also an exercise in learning how to construct a kernel. "),(0,i.kt)("p",null,"The following are some kernel notes."),(0,i.kt)("h3",{id:"userspace-and-system-calls"},"Userspace and System Calls"),(0,i.kt)("p",null,"The kernel operates in a privileged mode (kernel space), while applications run in user space. To interact with the kernel, applications use system calls. These are predefined entry points that allow user-space applications to request services from the kernel, like reading from a file or sending data over a network."),(0,i.kt)("p",null,"Understanding and optimizing the interaction between user space and kernel space is crucial for OS development. Efficient system calls can significantly enhance the performance and responsiveness of the operating system. Here are a few aspects to consider:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"System Call Interface (SCI)"),": The SCI is the gateway between user applications and the kernel. Designing a clean and efficient SCI is essential for performance. It involves defining the system calls, their parameters, and the conventions for passing data between user space and kernel space.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Context Switching"),": Switching between user space and kernel space (and vice versa) involves saving and restoring the state of the CPU. Minimizing the overhead of context switches is critical for maintaining system performance.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Memory Management"),": The kernel is responsible for managing memory allocation for both kernel and user space. Efficient memory management algorithms and policies are necessary to ensure optimal use of available resources and to prevent issues like fragmentation and memory leaks.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Security and Isolation"),": The kernel must ensure that user-space applications cannot interfere with each other or with the kernel itself. Implementing proper isolation mechanisms, such as process separation and access controls, is vital for system stability and security.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Interrupt Handling"),": Efficiently handling hardware interrupts and exceptions is a key aspect of kernel design. The kernel must provide mechanisms for registering and handling interrupt service routines (ISRs) and ensuring that critical tasks are not unduly delayed."))),(0,i.kt)("h3",{id:"development-methods"},"Development Methods"),(0,i.kt)("p",null,"For this project, we've explored various development methods:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Bottom-Up Approach"),": Starting with the most fundamental aspects (like the bootloader and kernel) and gradually building up the system. This method ensures a solid foundation but can be slow and cumbersome.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Top-Down Approach"),": Beginning with high-level components and services and then implementing the underlying mechanisms. This can provide a quicker path to a working prototype but risks foundational issues that can be hard to fix later.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Modular Development"),": Focusing on developing independent modules that can be integrated later. This offers flexibility and parallel development but requires careful planning and robust interfaces between modules."))),(0,i.kt)("h3",{id:"bootloader"},"Bootloader"),(0,i.kt)("p",null,"As mentioned earlier, our bootloader is being developed with GNU GRUB compatibility in mind. The bootloader's job is to load the kernel into memory and pass control to it. Anvitha is spearheading this effort, ensuring that our custom bootloader can initialize the system correctly and hand over control to our kernel seamlessly."),(0,i.kt)("p",null,"The bootloader is a critical component because it bridges the firmware and the kernel. It must perform several tasks:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Hardware Initialization"),": Setting up essential hardware components and peripherals, such as initializing memory controllers and configuring CPU settings.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Loading the Kernel"),": Locating the kernel binary on the storage device, loading it into memory, and preparing the execution environment.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Passing Parameters"),": Providing the kernel with necessary parameters and information about the system's state, such as memory maps and boot arguments.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Transitioning Control"),": Safely transferring control from the bootloader to the kernel, ensuring that the system remains in a consistent state."))),(0,i.kt)("h3",{id:"kernel-to-user-space"},"Kernel to User Space"),(0,i.kt)("p",null,"Transitioning from kernel space to user space is a critical step in the OS boot process. After the kernel is loaded and initialized, it must start the first user-space process, often called the init process. This process is responsible for setting up the user environment and launching other essential services."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Process Management"),": The kernel handles the creation, scheduling, and termination of processes. It must maintain process control blocks (PCBs) for each process, which store information such as the process state, program counter, CPU registers, and memory allocation.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Inter-Process Communication (IPC)"),": Mechanisms like pipes, message queues, shared memory, and signals allow processes to communicate and synchronize their actions. Efficient IPC is crucial for the performance and functionality of the operating system.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"User Space Libraries"),": Libraries like the GNU C Library (glibc) provide standard APIs for system calls, abstracting the complexity of direct kernel interactions. These libraries are essential for developing user-space applications and ensuring compatibility across different systems."))),(0,i.kt)("h3",{id:"boot-processes"},"Boot Processes"),(0,i.kt)("p",null,"The boot process of an operating system involves several stages, from power-on to the running state of the OS:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Firmware Initialization"),": The BIOS or UEFI firmware initializes hardware components and performs a Power-On Self Test (POST). It then locates the bootloader on the storage device.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Bootloader Execution"),": The bootloader loads the kernel into memory, sets up the initial execution environment, and passes control to the kernel.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Kernel Initialization"),": The kernel initializes its subsystems, such as memory management, process scheduling, and device drivers. It then mounts the root filesystem and starts the init process.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"User Space Initialization"),": The init process sets up the user environment, starts essential services (like networking and logging), and launches the user interface or command-line shell."))),(0,i.kt)("h3",{id:"general-user-space-development"},"General User Space Development"),(0,i.kt)("p",null,"Developing user-space applications involves several key aspects:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Application Programming Interfaces (APIs)"),": Developers use APIs provided by user space libraries to interact with the operating system. These APIs abstract the complexities of system calls and hardware interactions.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Development Tools"),": Tools like compilers, debuggers, and integrated development environments (IDEs) facilitate the creation and testing of user-space applications. For example, GCC is a widely-used compiler for C/C++ programs, while GDB is a powerful debugger.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"User Interface"),": The user interface can be command-line-based (like bash) or graphical (like GNOME or KDE). Developing a robust and user-friendly interface is crucial for the usability of the operating system.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Package Management"),": Systems like APT, YUM, or pacman manage the installation, updating, and removal of software packages. A good package management system ensures that users can easily maintain their software environments."))),(0,i.kt)("p",null,"By focusing on these aspects, we aim to create a robust and efficient operating system from the ground up, ensuring each component is carefully designed and integrated."))}m.isMDXComponent=!0}}]);