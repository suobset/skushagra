"use strict";(self.webpackChunkskushagra=self.webpackChunkskushagra||[]).push([[2173],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=p(n),u=r,m=d["".concat(l,".").concat(u)]||d[u]||h[u]||o;return n?a.createElement(m,s(s({ref:t},c),{},{components:n})):a.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[d]="string"==typeof e?e:r,s[1]=i;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7945:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={slug:"newsletter4",title:"Metamorphosis.",authors:["suobset"],tags:["newsletter","academia","life"]},s="Metamorphosis",i={permalink:"/blog/newsletter4",source:"@site/blog/2024-03-10-newsletter4/index.md",title:"Metamorphosis.",description:"Newsletter 4 Banner | Washington D.C.",date:"2024-03-10T00:00:00.000Z",formattedDate:"March 10, 2024",tags:[{label:"newsletter",permalink:"/blog/tags/newsletter"},{label:"academia",permalink:"/blog/tags/academia"},{label:"life",permalink:"/blog/tags/life"}],readingTime:9.1,hasTruncateMarker:!0,authors:[{name:"Kushagra Srivastava",title:"I write, code, and create. Sometimes all at the same time.",url:"https://skushagra.com",imageURL:"https://avatars.githubusercontent.com/u/73229775?v=4",key:"suobset"}],frontMatter:{slug:"newsletter4",title:"Metamorphosis.",authors:["suobset"],tags:["newsletter","academia","life"]},nextItem:{title:"Career Optimism, and History.",permalink:"/blog/newsletter3"}},l={authorsImageUrls:[void 0]},p=[{value:"The Times of Uncertainty, and my love for PyGDB",id:"the-times-of-uncertainty-and-my-love-for-pygdb",level:2},{value:"Background",id:"background",level:2},{value:"Tracers",id:"tracers",level:2},{value:"A Debugging Approach to Tracing",id:"a-debugging-approach-to-tracing",level:2}],c={toc:p},d="wrapper";function h(e){let{components:t,...o}=e;return(0,r.kt)(d,(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Newsletter 4 Banner | Washington D.C.",src:n(7339).Z,width:"4032",height:"3024"})),(0,r.kt)("p",null,"Slightly late blog update this week, owing mainly to the amounts of midterms and the thesis progress that had to be made last week. However, we are back and kicking: and I hope that I will be able to keep this momentum up next week as well. In today's newsletter, I would love to highlight some fun code I wrote for my Honors Thesis last semester."),(0,r.kt)("p",null,"The banner for this newsletter was taken on my trip to Washington D.C. Fall 2023, during the U.S. Census Department's Justice Week Event. I was one of the 6 people who worked on ",(0,r.kt)("a",{parentName:"p",href:"https://suobset.github.io/assert"},"ASSERT"),", a GIS Web-App that directs emergency responders (like Eversource, National Grid) to counties that are more vulnerable to energy inequity. A lot of data processing and web development later, we were able to successfully demo our product, which earnwed us a spot on the Census Department's ",(0,r.kt)("a",{parentName:"p",href:"https://opportunity.census.gov/showcase/?year=2023&partner-agency=Department+of+Energy"},"website"),". "),(0,r.kt)("p",null,"More details on ASSERT can be found in the Research Section of my website ",(0,r.kt)("a",{parentName:"p",href:"https://skushagra.com/docs/research/ongoing#umass-integrated-concentration-in-sciences-icons"},"here"),", though once the project is done forever the location may move to the ",(0,r.kt)("a",{parentName:"p",href:"https://skushagra.com/docs/research/icons"},"iCons Page here"),"."),(0,r.kt)("h2",{id:"the-times-of-uncertainty-and-my-love-for-pygdb"},"The Times of Uncertainty, and my love for PyGDB"),(0,r.kt)("p",null,"It is during the times of uncertainty that I believe the best things happen. Such was the case for ASSERT mentioned above, and I believe such will be the case for life ahead. I touched upon how I wanted to work in Systems in Grad School in my last post, and so I thought I'd go a little deeper into my biggest formal systems project as of right now: the Honors Thesis. "),(0,r.kt)("p",null,"The following is not going to be a deep dive into the intricacies of my project, I'd rather have people look out for my formal thesis for that one. However, I do want to pick out a certain aspect of the project, in an effort to hopefully demonstrate my approach towards problem solving. "),(0,r.kt)("h2",{id:"background"},"Background"),(0,r.kt)("p",null,"For my thesis, I am trying to compare performance differences between RUST and C++. I go more over the details in the Research -> Ongoing portion of my website, but in a nutshell here's the workflow"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Write the same program on RUST and C++"),(0,r.kt)("li",{parentName:"ul"},"Execute and extract the Assembly (on x86 platforms)"),(0,r.kt)("li",{parentName:"ul"},"Assemble and run, and trace the assembly's execution"),(0,r.kt)("li",{parentName:"ul"},"Analyze trace files")),(0,r.kt)("p",null,"My big hurdle in the past semester was point 3, the tracing of an Assembly file's run. I wanted to basically capture each Assembly instruction (for jumps and compare), and write them out to a file as they got executed. Here's the story of how I achieved it:"),(0,r.kt)("h2",{id:"tracers"},"Tracers"),(0,r.kt)("p",null,"Until 2 semesters ago, I had dealt with a lot of techniques pertaining to decompilation, reverse engineering, and the like. The most stable way to parse through an Assembly File was this RUST program I came up with:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"use std::arch::asm;\n\npub fn assembly() {\n    unsafe {\n        asm!(\n            // paste the assembly code here\n        );\n    }\n}\n")),(0,r.kt)("p",null,"However, this approach caused a lot of issues. For once, it introduced RUST overhead, which would skew off calculations if we are trying to compare between RUSt and C++. Moreover, there was still no way of actually running Assembly on bare metal and recording metrics off of that."),(0,r.kt)("p",null,"We needed to put decompilation, Ghidra, and RUST Inline Assembly aside; we needed to start from scratch."),(0,r.kt)("p",null,"To begin, I wrote a small program serving as a testbench, and extracted the x86 Asm:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"int main(){\n    int j = 0;\n    for(int i = 0; i < 10; ++i){\n        j = j + 100;\n        if(i % 2 == 0){\n            j = j - 1;\n        }else{\n            j = j + 1;\n        }\n    }\n    return 0;\n}\n")),(0,r.kt)("p",null,"I extracted the x86 Asm, and tried to make some changes to the bare files in a manner that would print a statement on the terminal before every jump."),(0,r.kt)("p",null,"This method was inspired by Prof. Joe Chiu's Python Bytecode Tracer, which adds similar print statements in the Python Bytecode to trace the same. Here's a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/terry3800/python_tracing_tool-1"},"link"),". The choice of the registers here was based on ones that store variables in the x86 documentation, and through lots of trial and error and reading documentations. "),(0,r.kt)("p",null,"For now, we are also only tracing Jumps and Compares."),(0,r.kt)("p",null,"My x86 Asm implementation was pretty janky, here's what a Snippet looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'.LBB0_1:                                # =>This Inner Loop Header: Depth=1\n    # User Code\n     lea    .LBB0_1_message(%rip), %rdi\n     call   printf\n    # User Code\n    lea     .LBB0_7_message(%rip), %rdi\n    call    printf\n    cmpl    $10, -8(%rbp)\n    jge .LBB0_7\n    # User Code\n    lea     .No_jmp_message(%rip), %rdi\n    call    printf\n\n# User code below serving as helper functions to print\n.LBB0_1_message:\n    .asciz  "jmp .LBB0_1\\n"\n.LBB0_7_message:\n    .asciz  "jmp .LBB0_7\\n"\n.No_jmp_message:\n    .asciz  "No Jmp\\n"\n')),(0,r.kt)("p",null,"This, did not work. The registers ",(0,r.kt)("inlineCode",{parentName:"p"},"%rip")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"%rdi")," would get severly messed up, and result in a plethora of Segfaults that were honestly near impossible to debug. "),(0,r.kt)("p",null,"Most importantly, we were messing with the values in pre-defined registers, which could (and did) mess up program execution. So, the problem persisted and we marched forward bravely. "),(0,r.kt)("p",null,"I tried to use a stack to maintain the old values of ",(0,r.kt)("inlineCode",{parentName:"p"},"%rip")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"%rdi"),", do the print, and then pop those values back into the respective registers. Equally janky snippet:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'.LBB0_1:                                # =>This Inner Loop Header: Depth=1\n    # Save the values of %rip and %rdi onto the stack\n    pushq   %rip\n    pushq   %rdi\n    \n    # Load the address of the message string onto %rdi\n    lea     .LBB0_1_message(%rip), %rdi\n    \n    # Call printf\n    call    printf\n\n    # Restore the values of %rip and %rdi from the stack\n    popq    %rdi\n    popq    %rip\n    # Save the values of %rip and %rdi onto the stack\n    pushq   %rip\n    pushq   %rdi\n\n.LBB0_1_message:\n    .asciz  "jmp .LBB0_1\\n"\n')),(0,r.kt)("p",null,"My third, equally short-lived implementation was to use my own variables instead of the Stack. I also tried printing using my own variables. Both did not work:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"    # User Code\n    # pushq %rip\n    movq    %rdi, saved_rdi\n    lea     .No_jmp_message(%rip), %rdi\n    call    printf\n    movq    saved_rdi, %rdi\n")),(0,r.kt)("p",null,"This also did not work, probably due to the reasons mentioned before. After all, the Stack was just a band-aid to solve an issue that was secondary; the execution of this Assembly code was still causing issues with tracing. "),(0,r.kt)("p",null,"For one, if we were to measure how efficient a programming language was based on tracing their Assembly outputs, it seemed counter-intuitive to edit such Assembly files. "),(0,r.kt)("p",null,"But secondly, the execution of all these three edits seemed dubious at best. Even if we run the same program with the same inputs, sometimes these prints would work and sometimes they wouldn't. They were not reliable at all, and did not provide an accurate trace. "),(0,r.kt)("p",null,"So far, here's a list of everything wrong with this method:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Does not work well",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Messes up stacks, registers, values of core registers"),(0,r.kt)("li",{parentName:"ul"},"Segmentation Fault Minefield"),(0,r.kt)("li",{parentName:"ul"},"Needs to uniformly change Asm files through a janky script"),(0,r.kt)("li",{parentName:"ul"},"And pray that it executes well"))),(0,r.kt)("li",{parentName:"ul"},"For real life programs with hundreds of files, does not work well",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Cannot go outside the context of one file"),(0,r.kt)("li",{parentName:"ul"},"Can break interoperability"))),(0,r.kt)("li",{parentName:"ul"},"Most importantly, false metrics can be analyzed, since we are adding our own jumps and calls")),(0,r.kt)("p",null,"It was time to switch my methodology. "),(0,r.kt)("h2",{id:"a-debugging-approach-to-tracing"},"A Debugging Approach to Tracing"),(0,r.kt)("p",null,"I went back to the drawing board for a bit. What we want to do is trace a file; we are essentially looking at this Assembly File and seeing it's behaviors across different commands, variables, and the like. "),(0,r.kt)("p",null,"What I needed, was a debugging approach to tracing. Here's a quick cut to the chase, and a rundown of what I ended up doing. "),(0,r.kt)("p",null,"My primary debugger for low level systems stuff has been GNU GDB so far, and I am super comfortable with it. By nature, it has a lot of extensible capabilities, owing partly to the amount of time and community surrounding its development. "),(0,r.kt)("p",null,"Utilizing GNU GDB as our debugging tool, we leverage the 1v1 binary compatibility of LLVM. The x86 assembly generated from LLVM LLC seamlessly integrates with GDB, enabling us to step into each component, make observations, and generate a trace file. By assembling the x86 assembly with the appropriate -g flags, we can then employ GDB to generate a trace, providing valuable insights into the execution process."),(0,r.kt)("p",null,"I found PyGDB, a Python Package that acts as an API to GDB and helps us extend the functionality. So here's how everything works at the end:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Compile each program till the Assembly"),(0,r.kt)("li",{parentName:"ul"},"Assembly with GDB flags"),(0,r.kt)("li",{parentName:"ul"},"Start GDB, and my own Python program that notices each GDB step and notes down the execution state"),(0,r.kt)("li",{parentName:"ul"},"Output this data to a file, and you have a trace :D")),(0,r.kt)("p",null,"Here's the initial Python Script I had, for Jumps:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'import gdb\n\n# Define the file path where you want to save the log\nlog_file_path = "./gdb.trace"\n\n# Initialize a flag to track whether a \'jne\' or \'jge\' instruction was executed\njmp_detected = False\n\ndef log_jmp_event(event):\n    global jmp_detected  # Use the global flag to track if \'jne\' or \'jge\' was detected\n    pc = int(gdb.parse_and_eval("$pc"))\n    instruction = gdb.execute("x/i " + hex(pc), to_string=True)\n    \n    if "jne" in instruction or "jge" in instruction:\n        jmp_detected = True\n        with open(log_file_path, "a") as log_file:\n            log_file.write(f"{hex(pc)}: {instruction}\\n")\n\n# Connect the stop event to the log_jmp_event function\ngdb.events.stop.connect(log_jmp_event)\n\n# Define a command to check if \'jne\' or \'jge\' was executed and write to the log file\nclass CheckJmpCommand(gdb.Command):\n    def __init__(self):\n        super(CheckJmpCommand, self).__init__("checkjmp", gdb.COMMAND_USER)\n\n    def invoke(self, arg, from_tty):\n        global jmp_detected\n        with open(log_file_path, "a") as log_file:\n            if jmp_detected:\n                log_file.write("jne/jge was executed.\\n")\n            else:\n                log_file.write("jne/jge was NOT executed.\\n")\n        jmp_detected = False  # Reset the flag for the next check\n\nCheckJmpCommand()\n')),(0,r.kt)("p",null,"Here's how the actual execution takes place:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Start GDB and load your Assembly files"),(0,r.kt)("li",{parentName:"ul"},"Attach this Code to GDB"),(0,r.kt)("li",{parentName:"ul"},"Run, step into each command"),(0,r.kt)("li",{parentName:"ul"},"During each step:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Detect Jumps"),(0,r.kt)("li",{parentName:"ul"},"If a jump is detected while executing code",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Log it in a file"))))),(0,r.kt)("li",{parentName:"ul"},"Repeat until end")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"GDB With Test Program",src:n(3660).Z,width:"859",height:"480"})),(0,r.kt)("p",null,"Here's what the snippet of an end trace for just Jumps looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0x40120d: => 0x40120d <_main+71>:   jne    0x401219 <_main+83>\n\n0x40128b: => 0x40128b <list_directory+107>: jne    0x40125b <list_directory+59>\n\n0x40128b: => 0x40128b <list_directory+107>: jne    0x40125b <list_directory+59>\n\n0x7ffff7fdc895: => 0x7ffff7fdc895 <_dl_fixup+117>:  jne    0x7ffff7fdca9c <_dl_fixup+636>\n\n0x7ffff7fdc89f: => 0x7ffff7fdc89f <_dl_fixup+127>:  jne    0x7ffff7fdca70 <_dl_fixup+592>\n")),(0,r.kt)("p",null,"The best part: the Python as an API implementation is extensible, and can incorporate really any variables or states that you'd want to incorporate. "),(0,r.kt)("p",null,"The above is the initial version of the tracer I had, and I'd be very excited to show the end results soon as my thesis comes out. "),(0,r.kt)("p",null,"I know some of the explanations seem cut short, but I am saving them up for the thesis. This blog was to just give some hints on what I am doing, and how Systems programming can sometimes be a success through entirely unexpected means. "),(0,r.kt)("p",null,"Until next time :D"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"RUST Example",src:n(5966).Z,width:"1191",height:"633"})))}h.isMDXComponent=!0},3660:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/image-588e5811316867176be7a2ae66e87ccf.png"},5966:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/image2-5dee2add3528e89df04e348b2ee13869.png"},7339:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/newsletter4fin-eb42fab26e619f30caf3e7ddf7589b93.png"}}]);